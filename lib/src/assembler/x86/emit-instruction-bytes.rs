/*
 * Permission is hereby granted, free of charge, to any human obtaining a copy of this software and associated documentation files
 * (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify,
 * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit humans to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

// We want to provide infomation about instruction encoding (prefixes and opcodes) in the type argument to make sure pointless code
// wouldn't be generated (in C++ that was achieved with “if constexpr”, but there are no “if constexpr” in Rust).
//
// This is done with two main helper types: 𝐮𝐧𝐟𝐢𝐥𝐥𝐞𝐝_𝐟𝐥𝐮𝐞𝐧𝐭_𝐯𝐚𝐥𝐮𝐞 and 𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞 (which is just a dummy empty type which
// carries a single byte as part of it's type).
#[allow(non_upper_case_globals)]
pub enum 𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<const 𝓫𝔂𝓽𝓮_𝓿𝓪𝓵𝓾𝓮: u8> {}
pub enum 𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱 {}

// Legacy instructions can include up to five legacy prefixes, plus, possibly, optional 0F, 0F 38, 0F 3A opcode extensions and one
// opcode byte after that.
// Additionally 3DNow! and some SSE/AVX instructions use immediate field as opcode extension.
#[allow(non_snake_case)]
pub struct 𝐥𝐞𝐠𝐚𝐜𝐲_𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧<
    𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁 = 𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
    𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 = 𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
    𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 = 𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
    𝓻𝓮𝓹ₓ_𝓹𝓻𝓮𝓯𝓲𝔁 = 𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
    𝓵𝓸𝓬𝓴_𝓹𝓻𝓮𝓯𝓲𝔁 = 𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
    𝔁𝟬𝗙_𝓹𝓻𝓮𝓯𝓲𝔁 = 𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
    𝔁𝟯𝘅_𝓹𝓻𝓮𝓯𝓲𝔁 = 𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
    𝓸𝓹𝓬𝓸𝓭𝓮 = 𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
    𝓲𝓶𝓶𝓮𝓭𝓲𝓪𝓽𝓮_𝓸𝓹𝓬𝓸𝓭𝓮 = 𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
> {
    _𝗌𝖾𝗀𝗆𝖾𝗇𝗍_𝗉𝗋𝖾𝖿𝗂𝗑: core::marker::PhantomData<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁>,
    _𝖽𝖺𝗍𝖺_𝗌𝗂𝗓𝖾_𝗉𝗋𝖾𝖿𝗂𝗑: core::marker::PhantomData<𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁>,
    _𝖺𝖽𝖽𝗋𝖾𝗌𝗌_𝗌𝗂𝗓𝖾_𝗉𝗋𝖾𝖿𝗂𝗑: core::marker::PhantomData<𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁>,
    _𝗋𝖾𝗉ₓ_𝗉𝗋𝖾𝖿𝗂𝗑: core::marker::PhantomData<𝓻𝓮𝓹ₓ_𝓹𝓻𝓮𝓯𝓲𝔁>,
    _𝗅𝗈𝖼𝗄_𝗉𝗋𝖾𝖿𝗂𝗑: core::marker::PhantomData<𝓵𝓸𝓬𝓴_𝓹𝓻𝓮𝓯𝓲𝔁>,
    _𝗑𝟬𝗙_𝗉𝗋𝖾𝖿𝗂𝗑: core::marker::PhantomData<𝔁𝟬𝗙_𝓹𝓻𝓮𝓯𝓲𝔁>,
    _𝗑𝟯𝘅_𝗉𝗋𝖾𝖿𝗂𝗑: core::marker::PhantomData<𝔁𝟯𝘅_𝓹𝓻𝓮𝓯𝓲𝔁>,
    _𝗈𝗉𝖼𝗈𝖽𝖾: core::marker::PhantomData<𝓸𝓹𝓬𝓸𝓭𝓮>,
    _𝗂𝗆𝗆𝖾𝖽𝗂𝖺𝗍𝖾_𝗈𝗉𝖼𝗈𝖽𝖾: core::marker::PhantomData<𝓲𝓶𝓶𝓮𝓭𝓲𝓪𝓽𝓮_𝓸𝓹𝓬𝓸𝓭𝓮>,
}

macro_rules! 𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊 {
    (𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍 $𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵:tt $𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼:tt $𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼:tt) => {
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍x $𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵 $𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼 $𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼 _𝖺𝗋𝗋𝖺𝗒 0 []);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍x $𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵 $𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼 $𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼 𝖺𝗋𝗋𝖺𝗒 1 [𝖺𝗋𝗋𝖺𝗒[0]]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍x $𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵 $𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼 $𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼 𝖺𝗋𝗋𝖺𝗒 2 [𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1]]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍x $𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵 $𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼 $𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼 𝖺𝗋𝗋𝖺𝗒 3 [𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1], 𝖺𝗋𝗋𝖺𝗒[2]]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍x $𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵 $𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼 $𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼
            𝖺𝗋𝗋𝖺𝗒 4 [𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1], 𝖺𝗋𝗋𝖺𝗒[2], 𝖺𝗋𝗋𝖺𝗒[3]]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍x $𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵 $𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼 $𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼
            𝖺𝗋𝗋𝖺𝗒 5 [𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1], 𝖺𝗋𝗋𝖺𝗒[2], 𝖺𝗋𝗋𝖺𝗒[3], 𝖺𝗋𝗋𝖺𝗒[4]]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍x $𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵 $𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼 $𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼
            𝖺𝗋𝗋𝖺𝗒 6 [𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1], 𝖺𝗋𝗋𝖺𝗒[2], 𝖺𝗋𝗋𝖺𝗒[3], 𝖺𝗋𝗋𝖺𝗒[4], 𝖺𝗋𝗋𝖺𝗒[5]]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍x $𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵 $𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼 $𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼
            𝖺𝗋𝗋𝖺𝗒 7 [𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1], 𝖺𝗋𝗋𝖺𝗒[2], 𝖺𝗋𝗋𝖺𝗒[3], 𝖺𝗋𝗋𝖺𝗒[4], 𝖺𝗋𝗋𝖺𝗒[5], 𝖺𝗋𝗋𝖺𝗒[6]]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍x $𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵 $𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼 $𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼
            𝖺𝗋𝗋𝖺𝗒 8 [𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1], 𝖺𝗋𝗋𝖺𝗒[2], 𝖺𝗋𝗋𝖺𝗒[3], 𝖺𝗋𝗋𝖺𝗒[4], 𝖺𝗋𝗋𝖺𝗒[5], 𝖺𝗋𝗋𝖺𝗒[6], 𝖺𝗋𝗋𝖺𝗒[7]]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍x $𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵 $𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼 $𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼
            𝖺𝗋𝗋𝖺𝗒 9 [𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1], 𝖺𝗋𝗋𝖺𝗒[2], 𝖺𝗋𝗋𝖺𝗒[3], 𝖺𝗋𝗋𝖺𝗒[4], 𝖺𝗋𝗋𝖺𝗒[5], 𝖺𝗋𝗋𝖺𝗒[6], 𝖺𝗋𝗋𝖺𝗒[7], 𝖺𝗋𝗋𝖺𝗒[8]]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍x $𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵 $𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼 $𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼
            𝖺𝗋𝗋𝖺𝗒 10 [𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1], 𝖺𝗋𝗋𝖺𝗒[2], 𝖺𝗋𝗋𝖺𝗒[3], 𝖺𝗋𝗋𝖺𝗒[4], 𝖺𝗋𝗋𝖺𝗒[5], 𝖺𝗋𝗋𝖺𝗒[6], 𝖺𝗋𝗋𝖺𝗒[7], 𝖺𝗋𝗋𝖺𝗒[8], 𝖺𝗋𝗋𝖺𝗒[9]]);
    };
    (𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍x [$([$($𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵:tt)*])*] [$([$($𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼:tt)*])*] [𝓸𝓹𝓬𝓸𝓭𝓮 𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁 $($𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼:ident)*]
               $𝓪𝓻𝓻𝓪𝔂_𝓷𝓪𝓶𝓮:ident $𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮:literal [$($𝓪𝓻𝓻𝓪𝔂_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼:tt)*]) => {
        #[allow(non_upper_case_globals)]
        impl<$($($𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵)*),*>
        𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝐥𝐞𝐠𝐚𝐜𝐲_𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧<$($($𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼)*),*>, $𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮>
        for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
            #[inline(always)]
            fn emit_prefixes_and_opcodes(
                &mut self, $𝓪𝓻𝓻𝓪𝔂_𝓷𝓪𝓶𝓮: [u8; $𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮],
            ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                self.emit_u8_array([𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁, $($𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼,)* 𝓸𝓹𝓬𝓸𝓭𝓮, $($𝓪𝓻𝓻𝓪𝔂_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
            }
            #[inline(always)]
            fn emit_prefixes_rex_and_opcodes(
                &mut self, 𝗋𝖾𝗑: u8, $𝓪𝓻𝓻𝓪𝔂_𝓷𝓪𝓶𝓮: [u8; $𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮],
            ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                self.emit_u8_array([𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁, $($𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼,)* 𝗋𝖾𝗑, 𝓸𝓹𝓬𝓸𝓭𝓮, $($𝓪𝓻𝓻𝓪𝔂_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
            }
        }
    };
    (𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍x [$([$($𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵:tt)*])*] [$([$($𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼:tt)*])*] [𝓸𝓹𝓬𝓸𝓭𝓮 $($𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼:ident)*]
               $𝓪𝓻𝓻𝓪𝔂_𝓷𝓪𝓶𝓮:ident $𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮:literal [$($𝓪𝓻𝓻𝓪𝔂_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼:tt)*]) => {
        #[allow(non_upper_case_globals)]
        impl<$($($𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵)*),*>
        𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝐥𝐞𝐠𝐚𝐜𝐲_𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧<$($($𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼)*),*>, $𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮>
        for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
            #[inline(always)]
            fn emit_prefixes_and_opcodes(
                &mut self, $𝓪𝓻𝓻𝓪𝔂_𝓷𝓪𝓶𝓮: [u8; $𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮],
            ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                self.emit_u8_array([$($𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼,)* 𝓸𝓹𝓬𝓸𝓭𝓮, $($𝓪𝓻𝓻𝓪𝔂_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
            }
            #[inline(always)]
            fn emit_prefixes_rex_and_opcodes(
                &mut self, 𝗋𝖾𝗑: u8, $𝓪𝓻𝓻𝓪𝔂_𝓷𝓪𝓶𝓮: [u8; $𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮],
            ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                self.emit_u8_array([$($𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼,)* 𝗋𝖾𝗑, 𝓸𝓹𝓬𝓸𝓭𝓮, $($𝓪𝓻𝓻𝓪𝔂_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
            }
        }
        #[allow(non_upper_case_globals)]
        impl<$($($𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵)*),*>
        𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝐥𝐞𝐠𝐚𝐜𝐲_𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧<$($($𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼)*),*>, $𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮>
        for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
            #[inline(always)]
            fn emit_segment_prefixes_and_opcodes(
                &mut self, 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8, $𝓪𝓻𝓻𝓪𝔂_𝓷𝓪𝓶𝓮: [u8; $𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮],
            ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                self.emit_u8_array([𝗌𝖾𝗀𝗆𝖾𝗇𝗍, $($𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼,)* 𝓸𝓹𝓬𝓸𝓭𝓮, $($𝓪𝓻𝓻𝓪𝔂_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
            }
            #[inline(always)]
            fn emit_segment_prefixes_rex_and_opcodes(
                &mut self, 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8, 𝗋𝖾𝗑: u8, $𝓪𝓻𝓻𝓪𝔂_𝓷𝓪𝓶𝓮: [u8; $𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮],
            ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                self.emit_u8_array([𝗌𝖾𝗀𝗆𝖾𝗇𝗍, $($𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼,)* 𝗋𝖾𝗑, 𝓸𝓹𝓬𝓸𝓭𝓮, $($𝓪𝓻𝓻𝓪𝔂_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
            }
        }
    };
    (𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍_𝖙𝖞𝖕𝖊𝖘 [$($𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵:tt)*] [$($𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼:tt)*] [$($𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼:ident)*]
                     [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<𝓸𝓹𝓬𝓸𝓭𝓮>]) => {
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(
            𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍
            [[𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓] $($𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵)* [const 𝓸𝓹𝓬𝓸𝓭𝓮: u8]]
            [$($𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼)* [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<𝓸𝓹𝓬𝓸𝓭𝓮>] [𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱]]
            [𝓸𝓹𝓬𝓸𝓭𝓮 $($𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼)*]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(
            𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍
            [[𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓] $($𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵)* [const 𝓸𝓹𝓬𝓸𝓭𝓮: u8] [const 𝓲𝓶𝓶𝓮𝓭𝓲𝓪𝓽𝓮_𝓸𝓹𝓬𝓸𝓭𝓮: u8]]
            [$($𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼)* [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<𝓸𝓹𝓬𝓸𝓭𝓮>] [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<𝓲𝓶𝓶𝓮𝓭𝓲𝓪𝓽𝓮_𝓸𝓹𝓬𝓸𝓭𝓮>]]
            [𝓸𝓹𝓬𝓸𝓭𝓮 $($𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼)* 𝓲𝓶𝓶𝓮𝓭𝓲𝓪𝓽𝓮_𝓸𝓹𝓬𝓸𝓭𝓮]);
    };
    (𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍_𝖙𝖞𝖕𝖊𝖘 [$($𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵:tt)*] [$($𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼:tt)*] [$($𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼:ident)*]
                     [𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱] $($𝓽𝔂𝓹𝓮𝓼_𝓽𝓸_𝓹𝓻𝓸𝓬𝓮𝓼𝓼:tt)*) => {
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(
            𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍_𝖙𝖞𝖕𝖊𝖘
            [$($𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵)*]
            [$($𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼)* [𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱]]
            [$($𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼)*]
            $($𝓽𝔂𝓹𝓮𝓼_𝓽𝓸_𝓹𝓻𝓸𝓬𝓮𝓼𝓼)*);
    };
    (𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍_𝖙𝖞𝖕𝖊𝖘 [$($𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵:tt)*] [$($𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼:tt)*] [$($𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼:ident)*]
                     [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<$𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮:ident>] $($𝓽𝔂𝓹𝓮𝓼_𝓽𝓸_𝓹𝓻𝓸𝓬𝓮𝓼𝓼:tt)*) => {
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(
            𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍_𝖙𝖞𝖕𝖊𝖘
            [$($𝓽𝔂𝓹𝓮𝓼_𝓲𝓶𝓹𝓵)* [const $𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮: u8]]
            [$($𝓽𝔂𝓹𝓮_𝓹𝓪𝓻𝓪𝓶𝓼)* [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<$𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮>]]
            [$($𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮𝓼)* $𝓬𝓸𝓷𝓼𝓽_𝓿𝓪𝓵𝓾𝓮]
            $($𝓽𝔂𝓹𝓮𝓼_𝓽𝓸_𝓹𝓻𝓸𝓬𝓮𝓼𝓼)*);
    };
    (𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓻𝓮𝓹ₓ_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓵𝓸𝓬𝓴_𝓹𝓻𝓮𝓯𝓲𝔁:tt
                 [𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱]) => {
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(
            𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍_𝖙𝖞𝖕𝖊𝖘 [] [] [] $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓻𝓮𝓹ₓ_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓵𝓸𝓬𝓴_𝓹𝓻𝓮𝓯𝓲𝔁
            [𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱] [𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱] [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<𝓸𝓹𝓬𝓸𝓭𝓮>]);
    };
    (𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓻𝓮𝓹ₓ_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓵𝓸𝓬𝓴_𝓹𝓻𝓮𝓯𝓲𝔁:tt
                 $𝔁𝟬𝗙_𝓹𝓻𝓮𝓯𝓲𝔁:tt) => {
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(
            𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍_𝖙𝖞𝖕𝖊𝖘 [] [] [] $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓻𝓮𝓹ₓ_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓵𝓸𝓬𝓴_𝓹𝓻𝓮𝓯𝓲𝔁 $𝔁𝟬𝗙_𝓹𝓻𝓮𝓯𝓲𝔁
            [𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱] [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<𝓸𝓹𝓬𝓸𝓭𝓮>]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(
            𝖎𝖒𝖕𝖑_𝖜𝖎𝖙𝖍_𝖙𝖞𝖕𝖊𝖘 [] [] [] $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓻𝓮𝓹ₓ_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓵𝓸𝓬𝓴_𝓹𝓻𝓮𝓯𝓲𝔁 $𝔁𝟬𝗙_𝓹𝓻𝓮𝓯𝓲𝔁
            [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<𝔁𝟯𝘅_𝓹𝓻𝓮𝓯𝓲𝔁>] [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<𝓸𝓹𝓬𝓸𝓭𝓮>]);
    };
    (𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓻𝓮𝓹ₓ_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓵𝓸𝓬𝓴_𝓹𝓻𝓮𝓯𝓲𝔁:tt) => {
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(
            𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓻𝓮𝓹ₓ_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓵𝓸𝓬𝓴_𝓹𝓻𝓮𝓯𝓲𝔁
            [𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(
            𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓻𝓮𝓹ₓ_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓵𝓸𝓬𝓴_𝓹𝓻𝓮𝓯𝓲𝔁
            [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<𝔁𝟬𝗙_𝓹𝓻𝓮𝓯𝓲𝔁>]);
    };
    (𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓻𝓮𝓹ₓ_𝓹𝓻𝓮𝓯𝓲𝔁:tt) => {
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(
            𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓻𝓮𝓹ₓ_𝓹𝓻𝓮𝓯𝓲𝔁 [𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(
            𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓻𝓮𝓹ₓ_𝓹𝓻𝓮𝓯𝓲𝔁 [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<𝓵𝓸𝓬𝓴_𝓹𝓻𝓮𝓯𝓲𝔁>]);
    };
    (𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁:tt) => {
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(
            𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 [𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(
            𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<𝓻𝓮𝓹ₓ_𝓹𝓻𝓮𝓯𝓲𝔁>]);
    };
    (𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁:tt $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁:tt) => {
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 [𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁 $𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁 [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<𝓭𝓪𝓽𝓪_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁>]);
    };
    (𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁:tt) => {
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁 [𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 $𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁 [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<𝓪𝓭𝓭𝓻𝓮𝓼𝓼_𝓼𝓲𝔃𝓮_𝓹𝓻𝓮𝓯𝓲𝔁>]);
    };
    () => {
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 [𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱]);
        𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!(𝖉𝖊𝖋𝖎𝖓𝖊_𝖜𝖎𝖙𝖍 [𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓹𝓻𝓮𝓯𝓲𝔁>]);
    }
}

#[allow(non_upper_case_globals)]
pub trait 𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, const 𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮: usize>: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓
{
    fn emit_prefixes_and_opcodes(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮],
    ) -> Result<<Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, <Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞>;
    fn emit_prefixes_rex_and_opcodes(
        &mut self, 𝗋𝖾𝗑: u8, 𝖺𝗋𝗋𝖺𝗒: [u8; 𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮],
    ) -> Result<<Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, <Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞>;
}

#[allow(non_upper_case_globals)]
pub trait 𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, const 𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮: usize>: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓
{
    fn emit_segment_prefixes_and_opcodes(
        &mut self, 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8, 𝖺𝗋𝗋𝖺𝗒: [u8; 𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮],
    ) -> Result<<Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, <Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞>;
    fn emit_segment_prefixes_rex_and_opcodes(
        &mut self, 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8, 𝗋𝖾𝗑: u8, 𝖺𝗋𝗋𝖺𝗒: [u8; 𝓪𝓻𝓻𝓪𝔂_𝓼𝓲𝔃𝓮],
    ) -> Result<<Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, <Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞>;
}

𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊!();

// Five instructions have versions with register embedded in the opcode: 𝔡𝔢𝔠/𝔦𝔫𝔠/𝔪𝔬𝔳/𝔭𝔬𝔭/𝔭𝔲𝔰𝔥.
// And they can only ever accept data size prefix (0x66) or nothing.
// It's easier to implement precisely two required versions than teach
// 𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖕𝖗𝖊𝖋𝖎𝖝𝖊𝖘_𝖆𝖓𝖉_𝖔𝖕𝖈𝖔𝖉𝖊 to handle no-opcode instructions.
impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<
        𝐥𝐞𝐠𝐚𝐜𝐲_𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧<
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱>,
        1>
for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_prefixes_and_opcodes(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 1],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8_array(𝖺𝗋𝗋𝖺𝗒)
    }
    #[inline(always)]
    fn emit_prefixes_rex_and_opcodes(
        &mut self, 𝗋𝖾𝗑: u8, 𝖺𝗋𝗋𝖺𝗒: [u8; 1],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8_array([𝗋𝖾𝗑, 𝖺𝗋𝗋𝖺𝗒[0]])
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<
        𝐥𝐞𝐠𝐚𝐜𝐲_𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧<
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱>,
        2>
for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_prefixes_and_opcodes(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 2],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8_array(𝖺𝗋𝗋𝖺𝗒)
    }
    #[inline(always)]
    fn emit_prefixes_rex_and_opcodes(
        &mut self, 𝗋𝖾𝗑: u8, 𝖺𝗋𝗋𝖺𝗒: [u8; 2],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8_array([𝗋𝖾𝗑, 𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1]])
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<
        𝐥𝐞𝐠𝐚𝐜𝐲_𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧<
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱>,
        3>
for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_prefixes_and_opcodes(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 3],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8_array(𝖺𝗋𝗋𝖺𝗒)
    }
    #[inline(always)]
    fn emit_prefixes_rex_and_opcodes(
        &mut self, 𝗋𝖾𝗑: u8, 𝖺𝗋𝗋𝖺𝗒: [u8; 3],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8_array([𝗋𝖾𝗑, 𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1], 𝖺𝗋𝗋𝖺𝗒[2]])
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<
        𝐥𝐞𝐠𝐚𝐜𝐲_𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧<
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱>,
        5>
for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_prefixes_and_opcodes(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 5],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8_array(𝖺𝗋𝗋𝖺𝗒)
    }
    #[inline(always)]
    fn emit_prefixes_rex_and_opcodes(
        &mut self, 𝗋𝖾𝗑: u8, 𝖺𝗋𝗋𝖺𝗒: [u8; 5],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8_array([𝗋𝖾𝗑, 𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1], 𝖺𝗋𝗋𝖺𝗒[2], 𝖺𝗋𝗋𝖺𝗒[3], 𝖺𝗋𝗋𝖺𝗒[4]])
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<
        𝐥𝐞𝐠𝐚𝐜𝐲_𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧<
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱>,
        9>
for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_prefixes_and_opcodes(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 9],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8_array(𝖺𝗋𝗋𝖺𝗒)
    }
    #[inline(always)]
    fn emit_prefixes_rex_and_opcodes(
        &mut self, 𝗋𝖾𝗑: u8, 𝖺𝗋𝗋𝖺𝗒: [u8; 9],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8_array(
            [
                𝗋𝖾𝗑,
                𝖺𝗋𝗋𝖺𝗒[0],
                𝖺𝗋𝗋𝖺𝗒[1],
                𝖺𝗋𝗋𝖺𝗒[2],
                𝖺𝗋𝗋𝖺𝗒[3],
                𝖺𝗋𝗋𝖺𝗒[4],
                𝖺𝗋𝗋𝖺𝗒[5],
                𝖺𝗋𝗋𝖺𝗒[6],
                𝖺𝗋𝗋𝖺𝗒[7],
                𝖺𝗋𝗋𝖺𝗒[8]
            ]
        )
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<
        𝐥𝐞𝐠𝐚𝐜𝐲_𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧<
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<0x66>,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱>,
        1>
for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_prefixes_and_opcodes(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 1],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8_array([0x66, 𝖺𝗋𝗋𝖺𝗒[0]])
    }
    #[inline(always)]
    fn emit_prefixes_rex_and_opcodes(
        &mut self, 𝗋𝖾𝗑: u8, 𝖺𝗋𝗋𝖺𝗒: [u8; 1],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8_array([0x66, 𝗋𝖾𝗑, 𝖺𝗋𝗋𝖺𝗒[0]])
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<
        𝐥𝐞𝐠𝐚𝐜𝐲_𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧<
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<0x66>,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱>,
        3>
for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_prefixes_and_opcodes(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 3],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8_array([0x66, 𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1], 𝖺𝗋𝗋𝖺𝗒[2]])
    }
    #[inline(always)]
    fn emit_prefixes_rex_and_opcodes(
        &mut self, 𝗋𝖾𝗑: u8, 𝖺𝗋𝗋𝖺𝗒: [u8; 3],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8_array([0x66, 𝗋𝖾𝗑, 𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1], 𝖺𝗋𝗋𝖺𝗒[2]])
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<
        𝐥𝐞𝐠𝐚𝐜𝐲_𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧<
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<0x66>,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱>,
        5>
for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_prefixes_and_opcodes(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 5],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8_array([0x66, 𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1], 𝖺𝗋𝗋𝖺𝗒[2], 𝖺𝗋𝗋𝖺𝗒[3], 𝖺𝗋𝗋𝖺𝗒[4]])
    }
    #[inline(always)]
    fn emit_prefixes_rex_and_opcodes(
        &mut self, 𝗋𝖾𝗑: u8, 𝖺𝗋𝗋𝖺𝗒: [u8; 5],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8_array([0x66, 𝗋𝖾𝗑, 𝖺𝗋𝗋𝖺𝗒[0], 𝖺𝗋𝗋𝖺𝗒[1], 𝖺𝗋𝗋𝖺𝗒[2], 𝖺𝗋𝗋𝖺𝗒[3], 𝖺𝗋𝗋𝖺𝗒[4]])
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<
        𝐥𝐞𝐠𝐚𝐜𝐲_𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧<
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<0x0f>,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱>,
        1>
for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_prefixes_and_opcodes(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 1],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8_array([0x0f, 𝖺𝗋𝗋𝖺𝗒[0]])
    }
    #[inline(always)]
    fn emit_prefixes_rex_and_opcodes(
        &mut self, 𝗋𝖾𝗑: u8, 𝖺𝗋𝗋𝖺𝗒: [u8; 1],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8_array([𝗋𝖾𝗑, 0x0f, 𝖺𝗋𝗋𝖺𝗒[0]])
    }
}

impl<𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: 𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓>
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<
        𝐥𝐞𝐠𝐚𝐜𝐲_𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧<
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<0x66>,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐢𝐧𝐬𝐭𝐫𝐮𝐜𝐭𝐢𝐨𝐧_𝐛𝐲𝐭𝐞<0x0f>,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱,
            𝐧𝐨_𝐩𝐫𝐞𝐟𝐢𝐱>,
        1>
for 𝓫𝔂𝓽𝓮_𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {
    #[inline(always)]
    fn emit_prefixes_and_opcodes(
        &mut self, 𝖺𝗋𝗋𝖺𝗒: [u8; 1],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8_array([0x66, 0x0f, 𝖺𝗋𝗋𝖺𝗒[0]])
    }
    #[inline(always)]
    fn emit_prefixes_rex_and_opcodes(
        &mut self, 𝗋𝖾𝗑: u8, 𝖺𝗋𝗋𝖺𝗒: [u8; 1],
    ) -> Result<Self::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, Self::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
        self.emit_u8_array([0x66, 𝗋𝖾𝗑, 0x0f, 𝖺𝗋𝗋𝖺𝗒[0]])
    }
}

macro_rules! 𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖗𝖒_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓 {
    ($($𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮:ident($($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼:tt)*) => [$($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼:tt)*]),*) => {
        $(
            #[allow(clippy::unusual_byte_groupings)]
            #[inline(always)]
            fn $𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮<𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: core::convert::Into<u8>, 𝓻𝓶_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: core::convert::Into<u8>>(
                &mut self,
                𝗋𝖾𝗀: 𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮,
                𝗋𝗆: 𝓻𝓶_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮,
                $($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼)*
            ) -> Result<<Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, <Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                let 𝗋𝖾𝗀: u8 = 𝗋𝖾𝗀.into();
                let 𝗋𝗆: u8 = 𝗋𝗆.into();
                if 𝗋𝖾𝗀 & 0b1000 == 0 && 𝗋𝗆 & 0b1000 == 0 {
                    self.emit_prefixes_and_opcodes([0b11_000_000 | (𝗋𝖾𝗀 << 3) | 𝗋𝗆, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                } else {
                    self.emit_prefixes_rex_and_opcodes(
                        0b0100_0000 | ((𝗋𝖾𝗀 & 0b1000) >> 1) | ((𝗋𝗆 & 0b1000) >> 3),
                        [0b11_000_000 | ((𝗋𝖾𝗀 & 0b111) << 3) | (𝗋𝗆 & 0b111), $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*],
                    )
                }
            }
         )*
    }
}

macro_rules! 𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖗𝖒_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓_𝖜𝖎𝖙𝖍_𝖗𝖊𝖝𝟴 {
    ($($𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮:ident($($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼:tt)*) => [$($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼:tt)*]),*) => {
        $(
            #[allow(clippy::unusual_byte_groupings)]
            #[inline(always)]
            fn $𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮<𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: core::convert::Into<u8>, 𝓻𝓶_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: core::convert::Into<u8>>(
                &mut self,
                𝗋𝖾𝗀: 𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮,
                𝗋𝗆: 𝓻𝓶_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮,
                $($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼)*
            ) -> Result<<Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, <Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                let 𝗋𝖾𝗀: u8 = 𝗋𝖾𝗀.into();
                let 𝗋𝗆: u8 = 𝗋𝗆.into();
                if 𝗋𝖾𝗀 < 0b11 && 𝗋𝗆 < 0b11 {
                    self.emit_prefixes_and_opcodes([0b11_000_000 | (𝗋𝖾𝗀 << 3) | 𝗋𝗆, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                } else {
                    self.emit_prefixes_rex_and_opcodes(
                        0b0100_0000 | ((𝗋𝖾𝗀 & 0b1000) >> 1) | ((𝗋𝗆 & 0b1000) >> 3),
                        [0b11_000_000 | ((𝗋𝖾𝗀 & 0b111) << 3) | (𝗋𝗆 & 0b111), $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*],
                    )
                }
            }
         )*
    }
}

macro_rules! 𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖗𝖒_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓_𝖜𝖎𝖙𝖍_𝖗𝖊𝖝𝖜 {
    ($($𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮:ident($($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼:tt)*) => [$($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼:tt)*]),*) => {
        $(
            #[allow(clippy::unusual_byte_groupings)]
            #[inline(always)]
            fn $𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮<𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: core::convert::Into<u8>, 𝓻𝓶_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: core::convert::Into<u8>>(
                &mut self,
                𝗋𝖾𝗀: 𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮,
                𝗋𝗆: 𝓻𝓶_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮,
                $($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼)*
            ) -> Result<<Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, <Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                let 𝗋𝖾𝗀: u8 = 𝗋𝖾𝗀.into();
                let 𝗋𝗆: u8 = 𝗋𝗆.into();
                self.emit_prefixes_rex_and_opcodes(
                    0b0100_1000 | ((𝗋𝖾𝗀 & 0b1000) >> 1) | ((𝗋𝗆 & 0b1000) >> 3),
                    [0b11_000_000 | ((𝗋𝖾𝗀 & 0b111) << 3) | (𝗋𝗆 & 0b111), $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*],
                )
            }
         )*
    }
}

pub trait 𝒆𝒎𝒊𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼>:
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 0> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 1> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 2> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 3> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 4> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 5> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 6> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 7> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 8> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 9> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 10>
{
    𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖗𝖒_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓! {
        emit_legacy_reg_rm_instruction() => [],
        emit_legacy_reg_rm_instruction_with_u8(𝗏𝖺𝗅𝗎𝖾𝟣: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣],
        emit_legacy_reg_rm_instruction_with_i8(𝗏𝖺𝗅𝗎𝖾𝟣: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8],
        emit_legacy_reg_rm_instruction_with_2ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤],
        emit_legacy_reg_rm_instruction_with_2ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8],
        emit_legacy_reg_rm_instruction_with_u16(𝗏𝖺𝗅𝗎𝖾𝟣: u16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_rm_instruction_with_i16(𝗏𝖺𝗅𝗎𝖾𝟣: i16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_rm_instruction_with_4ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8, 𝗏𝖺𝗅𝗎𝖾𝟥: u8, 𝗏𝖺𝗅𝗎𝖾𝟦: u8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤, 𝗏𝖺𝗅𝗎𝖾𝟥, 𝗏𝖺𝗅𝗎𝖾𝟦],
        emit_legacy_reg_rm_instruction_with_4ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8, 𝗏𝖺𝗅𝗎𝖾𝟥: i8, 𝗏𝖺𝗅𝗎𝖾𝟦: i8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8, 𝗏𝖺𝗅𝗎𝖾𝟥 as u8, 𝗏𝖺𝗅𝗎𝖾𝟦 as u8],
        emit_legacy_reg_rm_instruction_with_u32(𝗏𝖺𝗅𝗎𝖾𝟣: u32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8],
        emit_legacy_reg_rm_instruction_with_i32(𝗏𝖺𝗅𝗎𝖾𝟣: i32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8]
    }
    𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖗𝖒_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓_𝖜𝖎𝖙𝖍_𝖗𝖊𝖝𝟴! {
        emit_legacy_reg_rm_instruction_with_rex8() => [],
        emit_legacy_reg_rm_instruction_with_rex8_and_u8(𝗏𝖺𝗅𝗎𝖾𝟣: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣],
        emit_legacy_reg_rm_instruction_with_rex8_and_i8(𝗏𝖺𝗅𝗎𝖾𝟣: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8],
        emit_legacy_reg_rm_instruction_with_rex8_and_2ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤],
        emit_legacy_reg_rm_instruction_with_rex8_and_2ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8],
        emit_legacy_reg_rm_instruction_with_rex8_and_u16(𝗏𝖺𝗅𝗎𝖾𝟣: u16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_rm_instruction_with_rex8_and_i16(𝗏𝖺𝗅𝗎𝖾𝟣: i16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_rm_instruction_with_rex8_and_4ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8, 𝗏𝖺𝗅𝗎𝖾𝟥: u8, 𝗏𝖺𝗅𝗎𝖾𝟦: u8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤, 𝗏𝖺𝗅𝗎𝖾𝟥, 𝗏𝖺𝗅𝗎𝖾𝟦],
        emit_legacy_reg_rm_instruction_with_rex8_and_4ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8, 𝗏𝖺𝗅𝗎𝖾𝟥: i8, 𝗏𝖺𝗅𝗎𝖾𝟦: i8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8, 𝗏𝖺𝗅𝗎𝖾𝟥 as u8, 𝗏𝖺𝗅𝗎𝖾𝟦 as u8],
        emit_legacy_reg_rm_instruction_with_rex8_and_u32(𝗏𝖺𝗅𝗎𝖾𝟣: u32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8],
        emit_legacy_reg_rm_instruction_with_rex8_and_i32(𝗏𝖺𝗅𝗎𝖾𝟣: i32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8]
    }
    𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖗𝖒_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓_𝖜𝖎𝖙𝖍_𝖗𝖊𝖝𝖜! {
        emit_legacy_reg_rm_instruction_with_rexw() => [],
        emit_legacy_reg_rm_instruction_with_rexw_and_u8(𝗏𝖺𝗅𝗎𝖾𝟣: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣],
        emit_legacy_reg_rm_instruction_with_rexw_and_i8(𝗏𝖺𝗅𝗎𝖾𝟣: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8],
        emit_legacy_reg_rm_instruction_with_rexw_and_2ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤],
        emit_legacy_reg_rm_instruction_with_rexw_and_2ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8],
        emit_legacy_reg_rm_instruction_with_rexw_and_u16(𝗏𝖺𝗅𝗎𝖾𝟣: u16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_rm_instruction_with_rexw_and_i16(𝗏𝖺𝗅𝗎𝖾𝟣: i16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_rm_instruction_with_rexw_and_4ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8, 𝗏𝖺𝗅𝗎𝖾𝟥: u8, 𝗏𝖺𝗅𝗎𝖾𝟦: u8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤, 𝗏𝖺𝗅𝗎𝖾𝟥, 𝗏𝖺𝗅𝗎𝖾𝟦],
        emit_legacy_reg_rm_instruction_with_rexw_and_4ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8, 𝗏𝖺𝗅𝗎𝖾𝟥: i8, 𝗏𝖺𝗅𝗎𝖾𝟦: i8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8, 𝗏𝖺𝗅𝗎𝖾𝟥 as u8, 𝗏𝖺𝗅𝗎𝖾𝟦 as u8],
        emit_legacy_reg_rm_instruction_with_rexw_and_u32(𝗏𝖺𝗅𝗎𝖾𝟣: u32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8],
        emit_legacy_reg_rm_instruction_with_rexw_and_i32(𝗏𝖺𝗅𝗎𝖾𝟣: i32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8]
    }
}

impl<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮:
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 0> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 1> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 2> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 3> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 4> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 5> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 6> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 7> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 8> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 9> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 10>>
𝒆𝒎𝒊𝒕_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼>
for 𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {}

macro_rules! 𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖆𝖉𝖉𝖗𝖊𝖘𝖘_𝟴𝟬𝟴𝟲_𝖒𝖊𝖒𝖔𝖗𝖞_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓 {
    ($($𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮:ident($($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼:tt)*) => [$($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼:tt)*]),*) => {
        $(
            #[allow(clippy::unusual_byte_groupings,non_upper_case_globals)]
            #[inline(always)]
            fn $𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮: core::convert::Into<u8>, 𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: core::convert::Into<u8>, const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>(
                &mut self,
                𝗋𝖾𝗀: 𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮,
                𝖺𝖽𝖽𝗋: 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮,
                                   super::𝗯𝗮𝘀𝗶𝗰_𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝐚𝐝𝐝𝐫𝐞𝐬𝐬_𝐛𝐚𝐬𝐞_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_16ᵇⁱᵗ,
                                   super::𝗯𝗮𝘀𝗶𝗰_𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝐚𝐝𝐝𝐫𝐞𝐬𝐬_𝐢𝐧𝐝𝐞𝐱_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫_16ᵇⁱᵗ,
                                   i16,
                                   𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>,
                $($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼)*
            ) -> Result<<Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, <Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                let 𝗋𝖾𝗀: u8 = 𝗋𝖾𝗀.into();
                let 𝖽𝗂𝗌𝖼𝗋𝗂𝗆𝗂𝗇𝖺𝗇𝗍: super::𝗯𝗮𝘀𝗶𝗰_𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝐚𝐝𝐝𝐫𝐞𝐬𝐬_8086_𝐝𝐢𝐬𝐜𝐫𝐢𝐦𝐢𝐧𝐚𝐧𝐭 = (
                    𝖺𝖽𝖽𝗋.𝖻𝖺𝗌𝖾,
                    𝖺𝖽𝖽𝗋.𝗂𝗇𝖽𝖾𝗑,
                ).into();
                if let Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍) = 𝖺𝖽𝖽𝗋.𝗌𝖾𝗀𝗆𝖾𝗇𝗍 {
                    let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                    if 𝖽𝗂𝗌𝖼𝗋𝗂𝗆𝗂𝗇𝖺𝗇𝗍 == super::𝗯𝗮𝘀𝗶𝗰_𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝐚𝐝𝐝𝐫𝐞𝐬𝐬_8086_𝐝𝐢𝐬𝐜𝐫𝐢𝐦𝐢𝐧𝐚𝐧𝐭::𝔫𝔬𝔫𝔢_𝔫𝔬𝔫𝔢 {
                        self.emit_segment_prefixes_and_opcodes(
                            𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b00_000_110 | (𝗋𝖾𝗀 << 3), 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8, (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                    } else {
                        let 𝗆𝗈𝖽𝗋𝗆_𝖻𝖺𝗌𝖾 = super::𝗯𝗮𝘀𝗶𝗰_𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝔞𝔡𝔡𝔯𝔢𝔰𝔰_8086_𝔡𝔦𝔰𝔠𝔯𝔦𝔪𝔦𝔫𝔞𝔫𝔱_𝔱𝔬_𝔪𝔬𝔡𝔯𝔪[𝖽𝗂𝗌𝖼𝗋𝗂𝗆𝗂𝗇𝖺𝗇𝗍 as usize];
                        if 𝖽𝗂𝗌𝖼𝗋𝗂𝗆𝗂𝗇𝖺𝗇𝗍 != super::𝗯𝗮𝘀𝗶𝗰_𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝐚𝐝𝐝𝐫𝐞𝐬𝐬_8086_𝐝𝐢𝐬𝐜𝐫𝐢𝐦𝐢𝐧𝐚𝐧𝐭::𝔟𝔭_𝔫𝔬𝔫𝔢 && 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 == 0 {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [𝗆𝗈𝖽𝗋𝗆_𝖻𝖺𝗌𝖾 | (𝗋𝖾𝗀 << 3), $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                        } else if 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as i8 as i16 == 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b01_000_000 | 𝗆𝗈𝖽𝗋𝗆_𝖻𝖺𝗌𝖾 | (𝗋𝖾𝗀 << 3), 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                        } else {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                [
                                     0b10_000_000 | 𝗆𝗈𝖽𝗋𝗆_𝖻𝖺𝗌𝖾 | (𝗋𝖾𝗀 << 3),
                                     𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                     (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                     $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ]
                            )
                        }
                    }
                } else if 𝖽𝗂𝗌𝖼𝗋𝗂𝗆𝗂𝗇𝖺𝗇𝗍 == super::𝗯𝗮𝘀𝗶𝗰_𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝐚𝐝𝐝𝐫𝐞𝐬𝐬_8086_𝐝𝐢𝐬𝐜𝐫𝐢𝐦𝐢𝐧𝐚𝐧𝐭::𝔫𝔬𝔫𝔢_𝔫𝔬𝔫𝔢 {
                    self.emit_prefixes_and_opcodes(
                        [0b00_000_110 | (𝗋𝖾𝗀 << 3), 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8, (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                } else {
                    let 𝗆𝗈𝖽𝗋𝗆_𝖻𝖺𝗌𝖾 = super::𝗯𝗮𝘀𝗶𝗰_𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝔞𝔡𝔡𝔯𝔢𝔰𝔰_8086_𝔡𝔦𝔰𝔠𝔯𝔦𝔪𝔦𝔫𝔞𝔫𝔱_𝔱𝔬_𝔪𝔬𝔡𝔯𝔪[𝖽𝗂𝗌𝖼𝗋𝗂𝗆𝗂𝗇𝖺𝗇𝗍 as usize];
                    if 𝖽𝗂𝗌𝖼𝗋𝗂𝗆𝗂𝗇𝖺𝗇𝗍 != super::𝗯𝗮𝘀𝗶𝗰_𝗮𝘀𝘀𝗲𝗺𝗯𝗹𝗲𝗿::𝐚𝐝𝐝𝐫𝐞𝐬𝐬_8086_𝐝𝐢𝐬𝐜𝐫𝐢𝐦𝐢𝐧𝐚𝐧𝐭::𝔟𝔭_𝔫𝔬𝔫𝔢 && 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 == 0 {
                        self.emit_prefixes_and_opcodes([𝗆𝗈𝖽𝗋𝗆_𝖻𝖺𝗌𝖾 | (𝗋𝖾𝗀 << 3), $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                    } else if 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as i8 as i16 == 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 {
                        self.emit_prefixes_and_opcodes(
                            [0b01_000_000 | 𝗆𝗈𝖽𝗋𝗆_𝖻𝖺𝗌𝖾 | (𝗋𝖾𝗀 << 3), 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                    } else {
                        self.emit_prefixes_and_opcodes(
                            [
                                0b10_000_000 | 𝗆𝗈𝖽𝗋𝗆_𝖻𝖺𝗌𝖾 | (𝗋𝖾𝗀 << 3),
                                𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                            ]
                        )
                    }
                }
            }
         )*
    }
}

macro_rules! 𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖆𝖉𝖉𝖗𝖊𝖘𝖘_𝟴𝟬𝟯𝟴𝟲_𝖒𝖊𝖒𝖔𝖗𝖞_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓 {
    ($($𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮:ident($($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼:tt)*) => [$($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼:tt)*]),*) => {
        $(
            #[allow(clippy::identity_op,clippy::unusual_byte_groupings,non_upper_case_globals)]
            #[inline(always)]
            fn $𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮<𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: core::convert::Into<u8>,
                              𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮: core::convert::Into<u8>,
                              𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮: core::convert::Into<u8>,
                              𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮: core::convert::Into<u8>,
                              𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮: Default + core::convert::Into<u8>,
                              const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>(
                &mut self,
                𝗋𝖾𝗀: 𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮,
                𝖺𝖽𝖽𝗋: 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, i32, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>,
                $($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼)*
            ) -> Result<<Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, <Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                let 𝗋𝖾𝗀: u8 = 𝗋𝖾𝗀.into();
                match (𝖺𝖽𝖽𝗋.𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝖺𝖽𝖽𝗋.𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋.𝗂𝗇𝖽𝖾𝗑) {
                    (None, None, None) => self.emit_prefixes_and_opcodes(
                        [
                            0b00_000_101 | (𝗋𝖾𝗀 << 3),
                            𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                            (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                            (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                            (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                            $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                        ],
                    ),
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), None, None) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        self.emit_segment_prefixes_and_opcodes(
                            𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                            [
                                0b00_000_101 | (𝗋𝖾𝗀 << 3),
                                𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                            ],
                        )
                    }
                    (None, Some(𝖻𝖺𝗌𝖾), None) => {
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 == 0 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_prefixes_and_opcodes([0b00_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_prefixes_and_opcodes([0b00_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_prefixes_and_opcodes(
                                    [0b01_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_prefixes_and_opcodes(
                                    [0b01_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖻𝖺𝗌𝖾 == 0b100 {
                            self.emit_prefixes_and_opcodes(
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_100,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_prefixes_and_opcodes(
                                [
                                    0b10_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), Some(𝖻𝖺𝗌𝖾), None) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 == 0 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b00_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b00_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b01_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b01_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖻𝖺𝗌𝖾 == 0b100 {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_100,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                [
                                    0b10_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (None, None, Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋.𝗌𝖼𝖺𝗅𝖾.into();
                        self.emit_prefixes_and_opcodes(
                            [
                                0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                0b00_000_101 | 𝗌𝖼𝖺𝗅𝖾 << 6 | 𝗂𝗇𝖽𝖾𝗑 << 3,
                                𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                            ],
                        )
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), None, Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋.𝗌𝖼𝖺𝗅𝖾.into();
                        self.emit_segment_prefixes_and_opcodes(
                            𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                            [
                                0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                0b00_000_101 | 𝗌𝖼𝖺𝗅𝖾 << 6 | 𝗂𝗇𝖽𝖾𝗑 << 3,
                                𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                            ],
                        )
                    }
                    (None, Some(𝖻𝖺𝗌𝖾), Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋.𝗌𝖼𝖺𝗅𝖾.into();
                        if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 == 0 {
                            self.emit_prefixes_and_opcodes(
                                [
                                     0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                     0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                     $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ]
                           )
                        } else if 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 {
                            self.emit_prefixes_and_opcodes(
                                [
                                     0b01_000_100 | (𝗋𝖾𝗀 << 3),
                                     0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                     𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                     $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ]
                            )
                        } else {
                            self.emit_prefixes_and_opcodes(
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), Some(𝖻𝖺𝗌𝖾), Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋.𝗌𝖼𝖺𝗅𝖾.into();
                        if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 == 0 {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ]
                             )
                        } else if 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                [
                                    0b01_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                }
            }
         )*
    }
}

macro_rules! 𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖆𝖉𝖉𝖗𝖊𝖘𝖘_𝖝𝟴𝟲_𝟲𝟰_𝖓𝖔𝖗𝖊𝖝_𝖒𝖊𝖒𝖔𝖗𝖞_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓 {
    ($($𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮:ident($($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼:tt)*) => [$($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼:tt)*]),*) => {
        $(
            #[allow(clippy::identity_op,clippy::unusual_byte_groupings,non_upper_case_globals)]
            #[inline(always)]
            fn $𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮<𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: core::convert::Into<u8>,
                              𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮: core::convert::Into<u8>,
                              𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮: core::convert::Into<u8>,
                              𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮: core::convert::Into<u8>,
                              𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮: Default + core::convert::Into<u8>,
                              const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>(
                &mut self,
                𝗋𝖾𝗀: 𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮,
                𝖺𝖽𝖽𝗋: 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, i32, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>,
                $($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼)*
            ) -> Result<<Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, <Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                let 𝗋𝖾𝗀: u8 = 𝗋𝖾𝗀.into();
                match (𝖺𝖽𝖽𝗋.𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝖺𝖽𝖽𝗋.𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋.𝗂𝗇𝖽𝖾𝗑) {
                    (None, None, None) => self.emit_prefixes_and_opcodes(
                        [
                            0b00_000_100 | (𝗋𝖾𝗀 << 3),
                            0b00_100_101,
                            𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                            (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                            (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                            (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                            $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                        ],
                    ),
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), None, None) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        self.emit_segment_prefixes_and_opcodes(
                            𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                            [
                                0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                0b00_100_101,
                                𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                            ],
                        )
                    }
                    (None, Some(𝖻𝖺𝗌𝖾), None) => {
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 == 0 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_prefixes_and_opcodes([0b00_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_prefixes_and_opcodes([0b00_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_prefixes_and_opcodes(
                                    [0b01_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_prefixes_and_opcodes(
                                    [0b01_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖻𝖺𝗌𝖾 == 0b100 {
                            self.emit_prefixes_and_opcodes(
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_100,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_prefixes_and_opcodes(
                                [
                                    0b10_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), Some(𝖻𝖺𝗌𝖾), None) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 == 0 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b00_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b00_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b01_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b01_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖻𝖺𝗌𝖾 == 0b100 {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_100,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                [
                                    0b10_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (None, None, Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋.𝗌𝖼𝖺𝗅𝖾.into();
                        self.emit_prefixes_and_opcodes(
                            [
                                0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                0b00_000_101 | 𝗌𝖼𝖺𝗅𝖾 << 6 | 𝗂𝗇𝖽𝖾𝗑 << 3,
                                𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                            ],
                        )
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), None, Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋.𝗌𝖼𝖺𝗅𝖾.into();
                        self.emit_segment_prefixes_and_opcodes(
                            𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                            [
                                0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                0b00_000_101 | 𝗌𝖼𝖺𝗅𝖾 << 6 | 𝗂𝗇𝖽𝖾𝗑 << 3,
                                𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                            ],
                        )
                    }
                    (None, Some(𝖻𝖺𝗌𝖾), Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋.𝗌𝖼𝖺𝗅𝖾.into();
                        if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 == 0 {
                            self.emit_prefixes_and_opcodes(
                                [
                                     0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                     0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                     $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ]
                           )
                        } else if 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 {
                            self.emit_prefixes_and_opcodes(
                                [
                                     0b01_000_100 | (𝗋𝖾𝗀 << 3),
                                     0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                     𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                     $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ]
                            )
                        } else {
                            self.emit_prefixes_and_opcodes(
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), Some(𝖻𝖺𝗌𝖾), Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋.𝗌𝖼𝖺𝗅𝖾.into();
                        if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 == 0 {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ]
                             )
                        } else if 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                [
                                    0b01_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                }
            }
         )*
    }
}

macro_rules! 𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖆𝖉𝖉𝖗𝖊𝖘𝖘_𝖝𝟴𝟲_𝟲𝟰_𝖒𝖊𝖒𝖔𝖗𝖞_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓 {
    ($($𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮:ident($($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼:tt)*) => [$($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼:tt)*]),*) => {
        $(
            #[allow(clippy::identity_op,clippy::unusual_byte_groupings,non_upper_case_globals)]
            #[inline(always)]
            fn $𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮<𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: core::convert::Into<u8>,
                              𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮: core::convert::Into<u8>,
                              𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮: core::convert::Into<u8>,
                              𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮: core::convert::Into<u8>,
                              𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮: Default + core::convert::Into<u8>,
                              const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>(
                &mut self,
                𝗋𝖾𝗀: 𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮,
                𝖺𝖽𝖽𝗋: 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, i32, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>,
                $($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼)*
            ) -> Result<<Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, <Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                let 𝗋𝖾𝗀: u8 = 𝗋𝖾𝗀.into();
                let mut 𝗋𝖾𝗑: u8 = 0b0100_0000 | ((𝗋𝖾𝗀 & 0b1000) >> 1);
                let 𝗋𝖾𝗀: u8 = 𝗋𝖾𝗀 & 0b111;
                match (𝖺𝖽𝖽𝗋.𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝖺𝖽𝖽𝗋.𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋.𝗂𝗇𝖽𝖾𝗑) {
                    (None, None, None) => {
                        if 𝗋𝖾𝗑 == 0b0100_0000 {
                            self.emit_prefixes_and_opcodes(
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_101,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_101,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), None, None) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        if 𝗋𝖾𝗑 == 0b0100_0000 {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_101,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_101,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (None, Some(𝖻𝖺𝗌𝖾), None) => {
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        𝗋𝖾𝗑 |= (𝖻𝖺𝗌𝖾 & 0b1000) >> 3;
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾 & 0b111;
                        if 𝗋𝖾𝗑 == 0b0100_0000 {
                            if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 == 0 {
                                if 𝖻𝖺𝗌𝖾 == 0b100 {
                                    self.emit_prefixes_and_opcodes([0b00_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                } else {
                                    self.emit_prefixes_and_opcodes([0b00_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                }
                            } else if 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 {
                                if 𝖻𝖺𝗌𝖾 == 0b100 {
                                    self.emit_prefixes_and_opcodes(
                                        [0b01_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                } else {
                                    self.emit_prefixes_and_opcodes(
                                        [0b01_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                }
                            } else if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_prefixes_and_opcodes(
                                    [
                                        0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                        0b00_100_100,
                                        𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            } else {
                                self.emit_prefixes_and_opcodes(
                                    [
                                        0b10_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾,
                                        𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            }
                        } else if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 == 0 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_prefixes_rex_and_opcodes(
                                    𝗋𝖾𝗑, [0b00_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_prefixes_rex_and_opcodes(𝗋𝖾𝗑, [0b00_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_prefixes_rex_and_opcodes(
                                    𝗋𝖾𝗑, [0b01_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_prefixes_rex_and_opcodes(
                                    𝗋𝖾𝗑, [0b01_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖻𝖺𝗌𝖾 == 0b100 {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑,
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_100,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑,
                                [
                                    0b10_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), Some(𝖻𝖺𝗌𝖾), None) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        𝗋𝖾𝗑 |= (𝖻𝖺𝗌𝖾 & 0b1000) >> 3;
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾 & 0b111;
                        if 𝗋𝖾𝗑 == 0b0100_0000 {
                            if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 == 0 {
                                if 𝖻𝖺𝗌𝖾 == 0b100 {
                                    self.emit_segment_prefixes_and_opcodes(
                                        𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b00_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                } else {
                                    self.emit_segment_prefixes_and_opcodes(
                                        𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b00_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                }
                            } else if 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 {
                                if 𝖻𝖺𝗌𝖾 == 0b100 {
                                    self.emit_segment_prefixes_and_opcodes(
                                        𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b01_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                } else {
                                    self.emit_segment_prefixes_and_opcodes(
                                        𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b01_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                }
                            } else if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                    [
                                        0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                        0b00_100_100,
                                        𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            } else {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                    [
                                        0b10_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾,
                                        𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            }
                        } else if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 == 0 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_segment_prefixes_rex_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗋𝖾𝗑, [0b00_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_segment_prefixes_rex_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗋𝖾𝗑, [0b00_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_segment_prefixes_rex_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗋𝖾𝗑, [0b01_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_segment_prefixes_rex_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗋𝖾𝗑, [0b01_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖻𝖺𝗌𝖾 == 0b100 {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑,
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_100,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑,
                                [
                                    0b10_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (None, None, Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        𝗋𝖾𝗑 |= (𝗂𝗇𝖽𝖾𝗑 & 0b1000) >> 2;
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑 & 0b111;
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋.𝗌𝖼𝖺𝗅𝖾.into();
                        if 𝗋𝖾𝗑 == 0b0100_0000 {
                            self.emit_prefixes_and_opcodes(
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_101 | 𝗌𝖼𝖺𝗅𝖾 << 6 | 𝗂𝗇𝖽𝖾𝗑 << 3,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_101 | 𝗌𝖼𝖺𝗅𝖾 << 6 | 𝗂𝗇𝖽𝖾𝗑 << 3,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), None, Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        𝗋𝖾𝗑 |= (𝗂𝗇𝖽𝖾𝗑 & 0b1000) >> 2;
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑 & 0b111;
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋.𝗌𝖼𝖺𝗅𝖾.into();
                        if 𝗋𝖾𝗑 == 0b0100_0000 {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_101 | 𝗌𝖼𝖺𝗅𝖾 << 6 | 𝗂𝗇𝖽𝖾𝗑 << 3,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_101 | 𝗌𝖼𝖺𝗅𝖾 << 6 | 𝗂𝗇𝖽𝖾𝗑 << 3,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (None, Some(𝖻𝖺𝗌𝖾), Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        𝗋𝖾𝗑 |= ((𝖻𝖺𝗌𝖾 & 0b1000) >> 3) | ((𝗂𝗇𝖽𝖾𝗑 & 0b1000) >> 2);
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾 & 0b111;
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑 & 0b111;
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋.𝗌𝖼𝖺𝗅𝖾.into();
                        if 𝗋𝖾𝗑 == 0b0100_0000 {
                            if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 == 0 {
                                self.emit_prefixes_and_opcodes(
                                    [
                                         0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                         0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                         $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ]
                                )
                            } else if 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 {
                                self.emit_prefixes_and_opcodes(
                                    [
                                         0b01_000_100 | (𝗋𝖾𝗀 << 3),
                                         0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                         𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                         $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ]
                                )
                            } else {
                                self.emit_prefixes_and_opcodes(
                                    [
                                        0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                        0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                        𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            }
                        } else if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 == 0 {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else if 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑,
                                [
                                    0b01_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑,
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), Some(𝖻𝖺𝗌𝖾), Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        𝗋𝖾𝗑 |= ((𝖻𝖺𝗌𝖾 & 0b1000) >> 3) | ((𝗂𝗇𝖽𝖾𝗑 & 0b1000) >> 2);
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾 & 0b111;
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑 & 0b111;
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋.𝗌𝖼𝖺𝗅𝖾.into();
                        if 𝗋𝖾𝗑 == 0b0100_0000 {
                            if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 == 0 {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                    [
                                        0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                        0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ]
                                )
                            } else if 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                    [
                                        0b01_000_100 | (𝗋𝖾𝗀 << 3),
                                        0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                        𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            } else {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                    [
                                        0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                        0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                        𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            }
                        } else if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 == 0 {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑,
                                [
                                     0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                     0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                     $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ]
                            )
                        } else if 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑,
                                [
                                    0b01_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑,
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                }
            }
         )*
    }
}

macro_rules! 𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖆𝖉𝖉𝖗𝖊𝖘𝖘_𝖝𝟴𝟲_𝟲𝟰_ₓ𝖎𝖕_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓 {
    ($($𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮:ident($($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼:tt)*) => [$($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼:tt)*]),*) => {
        $(
            #[allow(clippy::identity_op,clippy::unusual_byte_groupings,non_upper_case_globals)]
            #[inline(always)]
            fn $𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮<𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: core::convert::Into<u8>,
                              𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮: core::convert::Into<u8>,
                              𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮: core::convert::Into<u8>,
                              𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮: Default + core::convert::Into<u8>,
                              const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>(
                &mut self,
                𝗋𝖾𝗀: 𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮,
                𝖺𝖽𝖽𝗋: 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝐧𝐨_𝐢𝐧𝐝𝐞𝐱_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, i32, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>,
                $($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼)*
            ) -> Result<<Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, <Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                let 𝗋𝖾𝗀: u8 = 𝗋𝖾𝗀.into();
                let 𝗋𝖾𝗑: u8 = 0b0100_0000 | ((𝗋𝖾𝗀 & 0b1000) >> 1);
                let 𝗋𝖾𝗀: u8 = 𝗋𝖾𝗀 & 0b111;
                if 𝖺𝖽𝖽𝗋.𝖻𝖺𝗌𝖾.is_some() {
                    if let Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍) = 𝖺𝖽𝖽𝗋.𝗌𝖾𝗀𝗆𝖾𝗇𝗍 {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        if 𝗋𝖾𝗑 == 0b0100_0000 {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                [
                                    0b00_000_101 | (𝗋𝖾𝗀 << 3),
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑,
                                [
                                    0b00_000_101 | (𝗋𝖾𝗀 << 3),
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    } else {
                        if 𝗋𝖾𝗑 == 0b0100_0000 {
                            self.emit_prefixes_and_opcodes(
                                [
                                    0b00_000_101 | (𝗋𝖾𝗀 << 3),
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑,
                                [
                                    0b00_000_101 | (𝗋𝖾𝗀 << 3),
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                } else {
                    if let Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍) = 𝖺𝖽𝖽𝗋.𝗌𝖾𝗀𝗆𝖾𝗇𝗍 {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        if 𝗋𝖾𝗑 == 0b0100_0000 {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_101,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_101,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    } else {
                        if 𝗋𝖾𝗑 == 0b0100_0000 {
                            self.emit_prefixes_and_opcodes(
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_101,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_101,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                }
            }
         )*
    }
}

macro_rules! 𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖆𝖉𝖉𝖗𝖊𝖘𝖘_𝖝𝟴𝟲_𝟲𝟰_𝖒𝖊𝖒𝖔𝖗𝖞_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓_𝖜𝖎𝖙𝖍_𝖗𝖊𝖝𝟴 {
    ($($𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮:ident($($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼:tt)*) => [$($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼:tt)*]),*) => {
        $(
            #[allow(clippy::identity_op,clippy::unusual_byte_groupings,non_upper_case_globals)]
            #[inline(always)]
            fn $𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮<𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: core::convert::Into<u8>,
                              𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮: core::convert::Into<u8>,
                              𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮: core::convert::Into<u8>,
                              𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮: core::convert::Into<u8>,
                              𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮: Default + core::convert::Into<u8>,
                              const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>(
                &mut self,
                𝗋𝖾𝗀: 𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮,
                𝖺𝖽𝖽𝗋: 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, i32, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>,
                $($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼)*
            ) -> Result<<Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, <Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                let 𝗋𝖾𝗀: u8 = 𝗋𝖾𝗀.into();
                let mut 𝗋𝖾𝗑: u32 = 0b0100_0000 | ((𝗋𝖾𝗀 as u32 & 0b1000) >> 1) | (((𝗋𝖾𝗀 > 0b11) as u32) << 8);
                let 𝗋𝖾𝗀: u8 = 𝗋𝖾𝗀 & 0b111;
                match (𝖺𝖽𝖽𝗋.𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝖺𝖽𝖽𝗋.𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋.𝗂𝗇𝖽𝖾𝗑) {
                    (None, None, None) => {
                        if 𝗋𝖾𝗑 == 0b0100_0000 && 𝗋𝖾𝗀 & 0b100 == 0 {
                            self.emit_prefixes_and_opcodes(
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_101,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑 as u8,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_101,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), None, None) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        if 𝗋𝖾𝗑 == 0b0100_0000 && 𝗋𝖾𝗀 & 0b100 == 0 {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_101,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑 as u8,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_101,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (None, Some(𝖻𝖺𝗌𝖾), None) => {
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        𝗋𝖾𝗑 |= (𝖻𝖺𝗌𝖾 as u32 & 0b1000) >> 3;
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾 & 0b111;
                        if 𝗋𝖾𝗑 == 0b0100_0000 && 𝗋𝖾𝗀 & 0b100 == 0 {
                            if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 == 0 {
                                if 𝖻𝖺𝗌𝖾 == 0b100 {
                                    self.emit_prefixes_and_opcodes([0b00_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                } else {
                                    self.emit_prefixes_and_opcodes([0b00_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                }
                            } else if 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 {
                                if 𝖻𝖺𝗌𝖾 == 0b100 {
                                    self.emit_prefixes_and_opcodes(
                                        [0b01_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                } else {
                                    self.emit_prefixes_and_opcodes(
                                        [0b01_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                }
                            } else if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_prefixes_and_opcodes(
                                    [
                                        0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                        0b00_100_100,
                                        𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            } else {
                                self.emit_prefixes_and_opcodes(
                                    [
                                        0b10_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾,
                                        𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            }
                        } else if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 == 0 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_prefixes_rex_and_opcodes(
                                    𝗋𝖾𝗑 as u8, [0b00_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_prefixes_rex_and_opcodes(
                                    𝗋𝖾𝗑 as u8, [0b00_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_prefixes_rex_and_opcodes(
                                    𝗋𝖾𝗑 as u8, [0b01_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_prefixes_rex_and_opcodes(
                                    𝗋𝖾𝗑 as u8, [0b01_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖻𝖺𝗌𝖾 == 0b100 {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑 as u8,
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_100,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑 as u8,
                                [
                                    0b10_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), Some(𝖻𝖺𝗌𝖾), None) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        𝗋𝖾𝗑 |= (𝖻𝖺𝗌𝖾 as u32 & 0b1000) >> 3;
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾 & 0b111;
                        if 𝗋𝖾𝗑 == 0b0100_0000 && 𝗋𝖾𝗀 & 0b100 == 0 {
                            if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 == 0 {
                                if 𝖻𝖺𝗌𝖾 == 0b100 {
                                    self.emit_segment_prefixes_and_opcodes(
                                        𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b00_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                } else {
                                    self.emit_segment_prefixes_and_opcodes(
                                        𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b00_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                }
                            } else if 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 {
                                if 𝖻𝖺𝗌𝖾 == 0b100 {
                                    self.emit_segment_prefixes_and_opcodes(
                                        𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b01_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                } else {
                                    self.emit_segment_prefixes_and_opcodes(
                                        𝗌𝖾𝗀𝗆𝖾𝗇𝗍, [0b01_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                                }
                            } else if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                    [
                                        0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                        0b00_100_100,
                                        𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            } else {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                    [
                                        0b10_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾,
                                        𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            }
                        } else if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 == 0 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_segment_prefixes_rex_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗋𝖾𝗑 as u8, [0b00_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_segment_prefixes_rex_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗋𝖾𝗑 as u8, [0b00_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_segment_prefixes_rex_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                    𝗋𝖾𝗑 as u8,
                                    [
                                        0b01_000_100 | (𝗋𝖾𝗀 << 3),
                                        0b00_100_100,
                                        𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ]
                                )
                            } else {
                                self.emit_segment_prefixes_rex_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                    𝗋𝖾𝗑 as u8,
                                    [
                                        0b01_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾,
                                        𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ]
                                )
                            }
                        } else if 𝖻𝖺𝗌𝖾 == 0b100 {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑 as u8,
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_100,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑 as u8,
                                [
                                    0b10_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (None, None, Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        𝗋𝖾𝗑 |= (𝗂𝗇𝖽𝖾𝗑 as u32 & 0b1000) >> 2;
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑 & 0b111;
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋.𝗌𝖼𝖺𝗅𝖾.into();
                        if 𝗋𝖾𝗑 == 0b0100_0000 && 𝗋𝖾𝗀 & 0b100 == 0 {
                            self.emit_prefixes_and_opcodes(
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_101 | 𝗌𝖼𝖺𝗅𝖾 << 6 | 𝗂𝗇𝖽𝖾𝗑 << 3,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑 as u8,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_101 | 𝗌𝖼𝖺𝗅𝖾 << 6 | 𝗂𝗇𝖽𝖾𝗑 << 3,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), None, Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        𝗋𝖾𝗑 |= (𝗂𝗇𝖽𝖾𝗑 as u32 & 0b1000) >> 2;
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑 & 0b111;
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋.𝗌𝖼𝖺𝗅𝖾.into();
                        if 𝗋𝖾𝗑 == 0b0100_0000 && 𝗋𝖾𝗀 & 0b100 == 0 {
                            self.emit_segment_prefixes_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_101 | 𝗌𝖼𝖺𝗅𝖾 << 6 | 𝗂𝗇𝖽𝖾𝗑 << 3,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑 as u8,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_101 | 𝗌𝖼𝖺𝗅𝖾 << 6 | 𝗂𝗇𝖽𝖾𝗑 << 3,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (None, Some(𝖻𝖺𝗌𝖾), Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        𝗋𝖾𝗑 |= ((𝖻𝖺𝗌𝖾 as u32 & 0b1000) >> 3) | ((𝗂𝗇𝖽𝖾𝗑 as u32 & 0b1000) >> 2);
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾 & 0b111;
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑 & 0b111;
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋.𝗌𝖼𝖺𝗅𝖾.into();
                        if 𝗋𝖾𝗑 == 0b0100_0000 && 𝗋𝖾𝗀 & 0b100 == 0 {
                            if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 == 0 {
                                self.emit_prefixes_and_opcodes(
                                    [
                                        0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                        0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            } else if 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 {
                                self.emit_prefixes_and_opcodes(
                                    [
                                        0b01_000_100 | (𝗋𝖾𝗀 << 3),
                                        0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                        𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            } else {
                                self.emit_prefixes_and_opcodes(
                                    [
                                        0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                        0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                        𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            }
                        } else if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 == 0 {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑 as u8,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else if 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑 as u8,
                                [
                                    0b01_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑 as u8,
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), Some(𝖻𝖺𝗌𝖾), Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        𝗋𝖾𝗑 |= ((𝖻𝖺𝗌𝖾 as u32 & 0b1000) >> 3) | ((𝗂𝗇𝖽𝖾𝗑 as u32 & 0b1000) >> 2);
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾 & 0b111;
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑 & 0b111;
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋.𝗌𝖼𝖺𝗅𝖾.into();
                        if 𝗋𝖾𝗑 == 0b0100_0000 && 𝗋𝖾𝗀 & 0b100 == 0 {
                            if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 == 0 {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                    [
                                        0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                        0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            } else if 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                    [
                                        0b01_000_100 | (𝗋𝖾𝗀 << 3),
                                        0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                        𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            } else {
                                self.emit_segment_prefixes_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                    [
                                        0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                        0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                        𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                        (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                        $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                    ],
                                )
                            }
                        } else if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 == 0 {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑 as u8,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else if 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑 as u8,
                                [
                                    0b01_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑 as u8,
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                }
            }
         )*
    }
}

macro_rules! 𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖆𝖉𝖉𝖗𝖊𝖘𝖘_𝖝𝟴𝟲_𝟲𝟰_ₓ𝖎𝖕_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓_𝖜𝖎𝖙𝖍_𝖗𝖊𝖝𝟴 {
    ($($𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮:ident($($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼:tt)*) => [$($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼:tt)*]),*) => {
        $(
            #[allow(clippy::identity_op,clippy::unusual_byte_groupings,non_upper_case_globals)]
            #[inline(always)]
            fn $𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮<𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: core::convert::Into<u8>,
                              𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮: core::convert::Into<u8>,
                              𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮: core::convert::Into<u8>,
                              𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮: Default + core::convert::Into<u8>,
                              const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>(
                &mut self,
                𝗋𝖾𝗀: 𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮,
                𝖺𝖽𝖽𝗋: 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝐧𝐨_𝐢𝐧𝐝𝐞𝐱_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, i32, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>,
                $($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼)*
            ) -> Result<<Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, <Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                let 𝗋𝖾𝗀: u8 = 𝗋𝖾𝗀.into();
                let 𝗋𝖾𝗑: u8 = 0b0100_0000 | ((𝗋𝖾𝗀 & 0b1000) >> 1);
                let 𝗋𝖾𝗀: u8 = 𝗋𝖾𝗀 & 0b111;
                if 𝗋𝖾𝗑 == 0b0100_0000 && 𝗋𝖾𝗀 & 0b100 == 0 {
                    if let Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍) = 𝖺𝖽𝖽𝗋.𝗌𝖾𝗀𝗆𝖾𝗇𝗍 {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        self.emit_segment_prefixes_and_opcodes(
                            𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                            [
                                0b00_000_101 | (𝗋𝖾𝗀 << 3),
                                𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                            ],
                        )
                    } else {
                        self.emit_prefixes_and_opcodes(
                            [
                                0b00_000_101 | (𝗋𝖾𝗀 << 3),
                                𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                            ],
                        )
                    }
                } else {
                    if let Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍) = 𝖺𝖽𝖽𝗋.𝗌𝖾𝗀𝗆𝖾𝗇𝗍 {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        self.emit_segment_prefixes_rex_and_opcodes(
                            𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                            𝗋𝖾𝗑,
                            [
                                0b00_000_101 | (𝗋𝖾𝗀 << 3),
                                𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                            ],
                        )
                    } else {
                        self.emit_prefixes_rex_and_opcodes(
                            𝗋𝖾𝗑,
                            [
                                0b00_000_101 | (𝗋𝖾𝗀 << 3),
                                𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                            ],
                        )
                    }
                }
            }
         )*
    }
}

macro_rules! 𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖆𝖉𝖉𝖗𝖊𝖘𝖘_𝖝𝟴𝟲_𝟲𝟰_𝖒𝖊𝖒𝖔𝖗𝖞_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓_𝖜𝖎𝖙𝖍_𝖗𝖊𝖝𝖜 {
    ($($𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮:ident($($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼:tt)*) => [$($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼:tt)*]),*) => {
        $(
            #[allow(clippy::identity_op,clippy::unusual_byte_groupings,non_upper_case_globals)]
            #[inline(always)]
            fn $𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮<𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: core::convert::Into<u8>,
                              𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮: core::convert::Into<u8>,
                              𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮: core::convert::Into<u8>,
                              𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮: core::convert::Into<u8>,
                              𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮: Default + core::convert::Into<u8>,
                              const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>(
                &mut self,
                𝗋𝖾𝗀: 𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮,
                𝖺𝖽𝖽𝗋: 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝓲𝓷𝓭𝓮𝔁_𝓽𝔂𝓹𝓮, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, i32, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>,
                $($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼)*
            ) -> Result<<Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, <Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                let 𝗋𝖾𝗀: u8 = 𝗋𝖾𝗀.into();
                let mut 𝗋𝖾𝗑: u8 = 0b0100_1000 | ((𝗋𝖾𝗀 & 0b1000) >> 1);
                let 𝗋𝖾𝗀: u8 = 𝗋𝖾𝗀 & 0b111;
                match (𝖺𝖽𝖽𝗋.𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝖺𝖽𝖽𝗋.𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋.𝗂𝗇𝖽𝖾𝗑) {
                    (None, None, None) => self.emit_prefixes_rex_and_opcodes(
                        𝗋𝖾𝗑,
                        [
                            0b00_000_100 | (𝗋𝖾𝗀 << 3),
                            0b00_100_101,
                            𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                            (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                            (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                            (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                            $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                        ],
                    ),
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), None, None) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        self.emit_segment_prefixes_rex_and_opcodes(
                            𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                            𝗋𝖾𝗑,
                            [
                                0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                0b00_100_101,
                                𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                            ],
                        )
                    }
                    (None, Some(𝖻𝖺𝗌𝖾), None) => {
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        𝗋𝖾𝗑 |= (𝖻𝖺𝗌𝖾 & 0b1000) >> 3;
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾 & 0b111;
                        if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 == 0 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_prefixes_rex_and_opcodes(𝗋𝖾𝗑, [0b00_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_prefixes_rex_and_opcodes(𝗋𝖾𝗑, [0b00_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_prefixes_rex_and_opcodes(
                                    𝗋𝖾𝗑, [0b01_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_prefixes_rex_and_opcodes(
                                    𝗋𝖾𝗑, [0b01_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖻𝖺𝗌𝖾 == 0b100 {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑,
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_100,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑,
                                [
                                    0b10_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), Some(𝖻𝖺𝗌𝖾), None) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        𝗋𝖾𝗑 |= (𝖻𝖺𝗌𝖾 & 0b1000) >> 3;
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾 & 0b111;
                        if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 == 0 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_segment_prefixes_rex_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗋𝖾𝗑, [0b00_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_segment_prefixes_rex_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗋𝖾𝗑, [0b00_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 {
                            if 𝖻𝖺𝗌𝖾 == 0b100 {
                                self.emit_segment_prefixes_rex_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗋𝖾𝗑, [0b01_000_100 | (𝗋𝖾𝗀 << 3), 0b00_100_100, 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            } else {
                                self.emit_segment_prefixes_rex_and_opcodes(
                                    𝗌𝖾𝗀𝗆𝖾𝗇𝗍, 𝗋𝖾𝗑, [0b01_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾, 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8, $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*])
                            }
                        } else if 𝖻𝖺𝗌𝖾 == 0b100 {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑,
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_100_100,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑,
                                [
                                    0b10_000_000 | (𝗋𝖾𝗀 << 3) | 𝖻𝖺𝗌𝖾,
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (None, None, Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        𝗋𝖾𝗑 |= (𝗂𝗇𝖽𝖾𝗑 & 0b1000) >> 2;
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑 & 0b111;
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋.𝗌𝖼𝖺𝗅𝖾.into();
                        self.emit_prefixes_rex_and_opcodes(
                            𝗋𝖾𝗑,
                            [
                                0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                0b00_000_101 | 𝗌𝖼𝖺𝗅𝖾 << 6 | 𝗂𝗇𝖽𝖾𝗑 << 3,
                                𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                            ],
                        )
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), None, Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        𝗋𝖾𝗑 |= (𝗂𝗇𝖽𝖾𝗑 & 0b1000) >> 2;
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑 & 0b111;
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋.𝗌𝖼𝖺𝗅𝖾.into();
                        self.emit_segment_prefixes_rex_and_opcodes(
                            𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                            𝗋𝖾𝗑,
                            [
                                0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                0b00_000_101 | 𝗌𝖼𝖺𝗅𝖾 << 6 | 𝗂𝗇𝖽𝖾𝗑 << 3,
                                𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                            ],
                        )
                    }
                    (None, Some(𝖻𝖺𝗌𝖾), Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        𝗋𝖾𝗑 |= ((𝖻𝖺𝗌𝖾 & 0b1000) >> 3) | ((𝗂𝗇𝖽𝖾𝗑 & 0b1000) >> 2);
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾 & 0b111;
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑 & 0b111;
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋.𝗌𝖼𝖺𝗅𝖾.into();
                        if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 == 0 {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else if 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑,
                                [
                                    0b01_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_prefixes_rex_and_opcodes(
                                𝗋𝖾𝗑,
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                    (Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍), Some(𝖻𝖺𝗌𝖾), Some(𝗂𝗇𝖽𝖾𝗑)) => {
                        let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾.into();
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑.into();
                        𝗋𝖾𝗑 |= ((𝖻𝖺𝗌𝖾 & 0b1000) >> 3) | ((𝗂𝗇𝖽𝖾𝗑 & 0b1000) >> 2);
                        let 𝖻𝖺𝗌𝖾: u8 = 𝖻𝖺𝗌𝖾 & 0b111;
                        let 𝗂𝗇𝖽𝖾𝗑: u8 = 𝗂𝗇𝖽𝖾𝗑 & 0b111;
                        let 𝗌𝖼𝖺𝗅𝖾: u8 = 𝖺𝖽𝖽𝗋.𝗌𝖼𝖺𝗅𝖾.into();
                        if 𝖻𝖺𝗌𝖾 != 0b101 && 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 == 0 {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑,
                                [
                                    0b00_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else if 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as i8 as i32 == 𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑,
                                [
                                    0b01_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        } else {
                            self.emit_segment_prefixes_rex_and_opcodes(
                                𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                                𝗋𝖾𝗑,
                                [
                                    0b10_000_100 | (𝗋𝖾𝗀 << 3),
                                    0b00_000_000 | (𝗌𝖼𝖺𝗅𝖾 << 6) | (𝗂𝗇𝖽𝖾𝗑 << 3) | (𝖻𝖺𝗌𝖾 << 0),
                                    𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                                    (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                                    $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                                ],
                            )
                        }
                    }
                }
            }
         )*
    }
}

macro_rules! 𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖆𝖉𝖉𝖗𝖊𝖘𝖘_𝖝𝟴𝟲_𝟲𝟰_ₓ𝖎𝖕_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓_𝖜𝖎𝖙𝖍_𝖗𝖊𝖝𝖜 {
    ($($𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮:ident($($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼:tt)*) => [$($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼:tt)*]),*) => {
        $(
            #[allow(clippy::identity_op,clippy::unusual_byte_groupings,non_upper_case_globals)]
            #[inline(always)]
            fn $𝓯𝓾𝓷𝓬𝓽𝓲𝓸𝓷_𝓷𝓪𝓶𝓮<𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮: core::convert::Into<u8>,
                              𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮: core::convert::Into<u8>,
                              𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮: core::convert::Into<u8>,
                              𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮: Default + core::convert::Into<u8>,
                              const 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮: usize>(
                &mut self,
                𝗋𝖾𝗀: 𝓻𝓮𝓰_𝓻𝓮𝓰𝓲𝓼𝓽𝓮𝓻_𝓽𝔂𝓹𝓮,
                𝖺𝖽𝖽𝗋: 𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86<𝓼𝓮𝓰𝓶𝓮𝓷𝓽_𝓽𝔂𝓹𝓮, 𝓫𝓪𝓼𝓮_𝓽𝔂𝓹𝓮, 𝐧𝐨_𝐢𝐧𝐝𝐞𝐱_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫, 𝓼𝓬𝓪𝓵𝓮_𝓽𝔂𝓹𝓮, i32, 𝓶𝓮𝓶𝓸𝓻𝔂_𝓼𝓲𝔃𝓮>,
                $($𝓮𝔁𝓽𝓻𝓪_𝓹𝓪𝓻𝓪𝓶𝓮𝓽𝓮𝓻𝓼)*
            ) -> Result<<Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐫𝐞𝐬𝐮𝐥𝐭_𝐭𝐲𝐩𝐞, <Self as 𝒆𝒎𝒊𝒕𝒕𝒆𝒓>::𝐞𝐫𝐫𝐨𝐫_𝐭𝐲𝐩𝐞> {
                let 𝗋𝖾𝗀: u8 = 𝗋𝖾𝗀.into();
                let 𝗋𝖾𝗑: u8 = 0b0100_1000 | ((𝗋𝖾𝗀 & 0b1000) >> 1);
                let 𝗋𝖾𝗀: u8 = 𝗋𝖾𝗀 & 0b111;
                if let Some(𝗌𝖾𝗀𝗆𝖾𝗇𝗍) = 𝖺𝖽𝖽𝗋.𝗌𝖾𝗀𝗆𝖾𝗇𝗍 {
                    let 𝗌𝖾𝗀𝗆𝖾𝗇𝗍: u8 = 𝗌𝖾𝗀𝗆𝖾𝗇𝗍.into();
                    self.emit_segment_prefixes_rex_and_opcodes(
                        𝗌𝖾𝗀𝗆𝖾𝗇𝗍,
                        𝗋𝖾𝗑,
                        [
                            0b00_000_101 | (𝗋𝖾𝗀 << 3),
                            𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                            (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                            (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                            (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                            $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                        ],
                    )
                } else {
                    self.emit_prefixes_rex_and_opcodes(
                        𝗋𝖾𝗑,
                        [
                            0b00_000_101 | (𝗋𝖾𝗀 << 3),
                            𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 as u8,
                            (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 8) as u8,
                            (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 16) as u8,
                            (𝖺𝖽𝖽𝗋.𝖽𝗂𝗌𝗉 >> 24) as u8,
                            $($𝓮𝔁𝓽𝓻𝓪_𝓪𝓻𝓰𝓾𝓶𝓮𝓷𝓽𝓼)*
                        ],
                    )
                }
            }
         )*
    }
}

pub trait 𝒆𝒎𝒊𝒕_𝒎𝒆𝒎𝒐𝒓𝒚_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼>:
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 0> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 1> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 2> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 3> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 4> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 5> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 6> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 7> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 8> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 9> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 10> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 0> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 1> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 2> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 3> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 4> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 5> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 6> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 7> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 8> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 9> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 10>
{
    𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖆𝖉𝖉𝖗𝖊𝖘𝖘_𝟴𝟬𝟴𝟲_𝖒𝖊𝖒𝖔𝖗𝖞_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓! {
        emit_legacy_reg_address_8086_memory_instruction() => [],
        emit_legacy_reg_address_8086_memory_instruction_with_u8(𝗏𝖺𝗅𝗎𝖾𝟣: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣],
        emit_legacy_reg_address_8086_memory_instruction_with_i8(𝗏𝖺𝗅𝗎𝖾𝟣: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8],
        emit_legacy_reg_address_8086_memory_instruction_with_2ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤],
        emit_legacy_reg_address_8086_memory_instruction_with_2ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8],
        emit_legacy_reg_address_8086_memory_instruction_with_u16(𝗏𝖺𝗅𝗎𝖾𝟣: u16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_address_8086_memory_instruction_with_i16(𝗏𝖺𝗅𝗎𝖾𝟣: i16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_address_8086_memory_instruction_with_4ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8, 𝗏𝖺𝗅𝗎𝖾𝟥: u8, 𝗏𝖺𝗅𝗎𝖾𝟦: u8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤, 𝗏𝖺𝗅𝗎𝖾𝟥, 𝗏𝖺𝗅𝗎𝖾𝟦],
        emit_legacy_reg_address_8086_memory_instruction_with_4ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8, 𝗏𝖺𝗅𝗎𝖾𝟥: i8, 𝗏𝖺𝗅𝗎𝖾𝟦: i8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8, 𝗏𝖺𝗅𝗎𝖾𝟥 as u8, 𝗏𝖺𝗅𝗎𝖾𝟦 as u8],
        emit_legacy_reg_address_8086_memory_instruction_with_u32(𝗏𝖺𝗅𝗎𝖾𝟣: u32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8],
        emit_legacy_reg_address_8086_memory_instruction_with_i32(𝗏𝖺𝗅𝗎𝖾𝟣: i32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8]
    }
    𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖆𝖉𝖉𝖗𝖊𝖘𝖘_𝟴𝟬𝟯𝟴𝟲_𝖒𝖊𝖒𝖔𝖗𝖞_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓! {
        emit_legacy_reg_address_80386_memory_instruction() => [],
        emit_legacy_reg_address_80386_memory_instruction_with_u8(𝗏𝖺𝗅𝗎𝖾𝟣: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣],
        emit_legacy_reg_address_80386_memory_instruction_with_i8(𝗏𝖺𝗅𝗎𝖾𝟣: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8],
        emit_legacy_reg_address_80386_memory_instruction_with_2ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤],
        emit_legacy_reg_address_80386_memory_instruction_with_2ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8],
        emit_legacy_reg_address_80386_memory_instruction_with_u16(𝗏𝖺𝗅𝗎𝖾𝟣: u16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_address_80386_memory_instruction_with_i16(𝗏𝖺𝗅𝗎𝖾𝟣: i16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_address_80386_memory_instruction_with_4ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8, 𝗏𝖺𝗅𝗎𝖾𝟥: u8, 𝗏𝖺𝗅𝗎𝖾𝟦: u8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤, 𝗏𝖺𝗅𝗎𝖾𝟥, 𝗏𝖺𝗅𝗎𝖾𝟦],
        emit_legacy_reg_address_80386_memory_instruction_with_4ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8, 𝗏𝖺𝗅𝗎𝖾𝟥: i8, 𝗏𝖺𝗅𝗎𝖾𝟦: i8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8, 𝗏𝖺𝗅𝗎𝖾𝟥 as u8, 𝗏𝖺𝗅𝗎𝖾𝟦 as u8],
        emit_legacy_reg_address_80386_memory_instruction_with_u32(𝗏𝖺𝗅𝗎𝖾𝟣: u32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8],
        emit_legacy_reg_address_80386_memory_instruction_with_i32(𝗏𝖺𝗅𝗎𝖾𝟣: i32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8]
    }
    𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖆𝖉𝖉𝖗𝖊𝖘𝖘_𝖝𝟴𝟲_𝟲𝟰_𝖓𝖔𝖗𝖊𝖝_𝖒𝖊𝖒𝖔𝖗𝖞_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓! {
        emit_legacy_reg_address_ₓ86_64_norex_memory_instruction() => [],
        emit_legacy_reg_address_ₓ86_64_norex_memory_instruction_with_u8(𝗏𝖺𝗅𝗎𝖾𝟣: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣],
        emit_legacy_reg_address_ₓ86_64_norex_memory_instruction_with_i8(𝗏𝖺𝗅𝗎𝖾𝟣: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8],
        emit_legacy_reg_address_ₓ86_64_norex_memory_instruction_with_2ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤],
        emit_legacy_reg_address_ₓ86_64_norex_memory_instruction_with_2ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8],
        emit_legacy_reg_address_ₓ86_64_norex_memory_instruction_with_u16(𝗏𝖺𝗅𝗎𝖾𝟣: u16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_address_ₓ86_64_norex_memory_instruction_with_i16(𝗏𝖺𝗅𝗎𝖾𝟣: i16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_address_ₓ86_64_norex_memory_instruction_with_4ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8, 𝗏𝖺𝗅𝗎𝖾𝟥: u8, 𝗏𝖺𝗅𝗎𝖾𝟦: u8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤, 𝗏𝖺𝗅𝗎𝖾𝟥, 𝗏𝖺𝗅𝗎𝖾𝟦],
        emit_legacy_reg_address_ₓ86_64_norex_memory_instruction_with_4ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8, 𝗏𝖺𝗅𝗎𝖾𝟥: i8, 𝗏𝖺𝗅𝗎𝖾𝟦: i8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8, 𝗏𝖺𝗅𝗎𝖾𝟥 as u8, 𝗏𝖺𝗅𝗎𝖾𝟦 as u8],
        emit_legacy_reg_address_ₓ86_64_norex_memory_instruction_with_u32(𝗏𝖺𝗅𝗎𝖾𝟣: u32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8],
        emit_legacy_reg_address_ₓ86_64_norex_memory_instruction_with_i32(𝗏𝖺𝗅𝗎𝖾𝟣: i32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8]
    }
    𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖆𝖉𝖉𝖗𝖊𝖘𝖘_𝖝𝟴𝟲_𝟲𝟰_𝖒𝖊𝖒𝖔𝖗𝖞_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓! {
        emit_legacy_reg_address_ₓ86_64_memory_instruction() => [],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_u8(𝗏𝖺𝗅𝗎𝖾𝟣: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_i8(𝗏𝖺𝗅𝗎𝖾𝟣: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_2ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_2ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_u16(𝗏𝖺𝗅𝗎𝖾𝟣: u16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_i16(𝗏𝖺𝗅𝗎𝖾𝟣: i16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_4ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8, 𝗏𝖺𝗅𝗎𝖾𝟥: u8, 𝗏𝖺𝗅𝗎𝖾𝟦: u8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤, 𝗏𝖺𝗅𝗎𝖾𝟥, 𝗏𝖺𝗅𝗎𝖾𝟦],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_4ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8, 𝗏𝖺𝗅𝗎𝖾𝟥: i8, 𝗏𝖺𝗅𝗎𝖾𝟦: i8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8, 𝗏𝖺𝗅𝗎𝖾𝟥 as u8, 𝗏𝖺𝗅𝗎𝖾𝟦 as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_u32(𝗏𝖺𝗅𝗎𝖾𝟣: u32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_i32(𝗏𝖺𝗅𝗎𝖾𝟣: i32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8]
    }
    𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖆𝖉𝖉𝖗𝖊𝖘𝖘_𝖝𝟴𝟲_𝟲𝟰_ₓ𝖎𝖕_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓! {
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction() => [],
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_u8(𝗏𝖺𝗅𝗎𝖾𝟣: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣],
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_i8(𝗏𝖺𝗅𝗎𝖾𝟣: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8],
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_2ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤],
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_2ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8],
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_u16(𝗏𝖺𝗅𝗎𝖾𝟣: u16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_i16(𝗏𝖺𝗅𝗎𝖾𝟣: i16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_4ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8, 𝗏𝖺𝗅𝗎𝖾𝟥: u8, 𝗏𝖺𝗅𝗎𝖾𝟦: u8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤, 𝗏𝖺𝗅𝗎𝖾𝟥, 𝗏𝖺𝗅𝗎𝖾𝟦],
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_4ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8, 𝗏𝖺𝗅𝗎𝖾𝟥: i8, 𝗏𝖺𝗅𝗎𝖾𝟦: i8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8, 𝗏𝖺𝗅𝗎𝖾𝟥 as u8, 𝗏𝖺𝗅𝗎𝖾𝟦 as u8],
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_u32(𝗏𝖺𝗅𝗎𝖾𝟣: u32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8],
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_i32(𝗏𝖺𝗅𝗎𝖾𝟣: i32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8]
    }
    𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖆𝖉𝖉𝖗𝖊𝖘𝖘_𝖝𝟴𝟲_𝟲𝟰_𝖒𝖊𝖒𝖔𝖗𝖞_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓_𝖜𝖎𝖙𝖍_𝖗𝖊𝖝𝟴! {
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rex8() => [],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rex8_and_u8(𝗏𝖺𝗅𝗎𝖾𝟣: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rex8_and_i8(𝗏𝖺𝗅𝗎𝖾𝟣: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rex8_and_2ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rex8_and_2ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rex8_and_u16(𝗏𝖺𝗅𝗎𝖾𝟣: u16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rex8_and_i16(𝗏𝖺𝗅𝗎𝖾𝟣: i16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rex8_and_4ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8, 𝗏𝖺𝗅𝗎𝖾𝟥: u8, 𝗏𝖺𝗅𝗎𝖾𝟦: u8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤, 𝗏𝖺𝗅𝗎𝖾𝟥, 𝗏𝖺𝗅𝗎𝖾𝟦],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rex8_and_4ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8, 𝗏𝖺𝗅𝗎𝖾𝟥: i8, 𝗏𝖺𝗅𝗎𝖾𝟦: i8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8, 𝗏𝖺𝗅𝗎𝖾𝟥 as u8, 𝗏𝖺𝗅𝗎𝖾𝟦 as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rex8_and_u32(𝗏𝖺𝗅𝗎𝖾𝟣: u32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rex8_and_i32(𝗏𝖺𝗅𝗎𝖾𝟣: i32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8]
    }
    𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖆𝖉𝖉𝖗𝖊𝖘𝖘_𝖝𝟴𝟲_𝟲𝟰_ₓ𝖎𝖕_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓_𝖜𝖎𝖙𝖍_𝖗𝖊𝖝𝟴! {
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_rex8() => [],
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_rex8_and_u8(𝗏𝖺𝗅𝗎𝖾𝟣: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣],
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_rex8_and_i8(𝗏𝖺𝗅𝗎𝖾𝟣: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8],
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_rex8_and_2ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤],
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_rex8_and_2ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8],
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_rex8_and_u16(𝗏𝖺𝗅𝗎𝖾𝟣: u16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_rex8_and_i16(𝗏𝖺𝗅𝗎𝖾𝟣: i16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_rex8_and_4ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8, 𝗏𝖺𝗅𝗎𝖾𝟥: u8, 𝗏𝖺𝗅𝗎𝖾𝟦: u8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤, 𝗏𝖺𝗅𝗎𝖾𝟥, 𝗏𝖺𝗅𝗎𝖾𝟦],
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_rex8_and_4ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8, 𝗏𝖺𝗅𝗎𝖾𝟥: i8, 𝗏𝖺𝗅𝗎𝖾𝟦: i8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8, 𝗏𝖺𝗅𝗎𝖾𝟥 as u8, 𝗏𝖺𝗅𝗎𝖾𝟦 as u8],
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_rex8_and_u32(𝗏𝖺𝗅𝗎𝖾𝟣: u32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8],
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_rex8_and_i32(𝗏𝖺𝗅𝗎𝖾𝟣: i32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8]
    }
    𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖆𝖉𝖉𝖗𝖊𝖘𝖘_𝖝𝟴𝟲_𝟲𝟰_𝖒𝖊𝖒𝖔𝖗𝖞_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓_𝖜𝖎𝖙𝖍_𝖗𝖊𝖝𝖜! {
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rexw() => [],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rexw_and_u8(𝗏𝖺𝗅𝗎𝖾𝟣: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rexw_and_i8(𝗏𝖺𝗅𝗎𝖾𝟣: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rexw_and_2ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rexw_and_2ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rexw_and_u16(𝗏𝖺𝗅𝗎𝖾𝟣: u16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rexw_and_i16(𝗏𝖺𝗅𝗎𝖾𝟣: i16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rexw_and_4ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8, 𝗏𝖺𝗅𝗎𝖾𝟥: u8, 𝗏𝖺𝗅𝗎𝖾𝟦: u8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤, 𝗏𝖺𝗅𝗎𝖾𝟥, 𝗏𝖺𝗅𝗎𝖾𝟦],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rexw_and_4ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8, 𝗏𝖺𝗅𝗎𝖾𝟥: i8, 𝗏𝖺𝗅𝗎𝖾𝟦: i8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8, 𝗏𝖺𝗅𝗎𝖾𝟥 as u8, 𝗏𝖺𝗅𝗎𝖾𝟦 as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rexw_and_u32(𝗏𝖺𝗅𝗎𝖾𝟣: u32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8],
        emit_legacy_reg_address_ₓ86_64_memory_instruction_with_rexw_and_i32(𝗏𝖺𝗅𝗎𝖾𝟣: i32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8]
    }
    𝖉𝖊𝖋𝖎𝖓𝖊_𝖊𝖒𝖎𝖙_𝖑𝖊𝖌𝖆𝖈𝖞_𝖗𝖊𝖌_𝖆𝖉𝖉𝖗𝖊𝖘𝖘_𝖝𝟴𝟲_𝟲𝟰_ₓ𝖎𝖕_𝖎𝖓𝖘𝖙𝖗𝖚𝖈𝖙𝖎𝖔𝖓_𝖜𝖎𝖙𝖍_𝖗𝖊𝖝𝖜! {
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_rexw() => [],
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_rexw_and_u8(𝗏𝖺𝗅𝗎𝖾𝟣: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣],
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_rexw_and_i8(𝗏𝖺𝗅𝗎𝖾𝟣: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8],
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_rexw_and_2ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8) => [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤],
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_rexw_and_2ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8],
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_rexw_and_u16(𝗏𝖺𝗅𝗎𝖾𝟣: u16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_rexw_and_i16(𝗏𝖺𝗅𝗎𝖾𝟣: i16) => [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8],
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_rexw_and_4ₓu8(𝗏𝖺𝗅𝗎𝖾𝟣: u8, 𝗏𝖺𝗅𝗎𝖾𝟤: u8, 𝗏𝖺𝗅𝗎𝖾𝟥: u8, 𝗏𝖺𝗅𝗎𝖾𝟦: u8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣, 𝗏𝖺𝗅𝗎𝖾𝟤, 𝗏𝖺𝗅𝗎𝖾𝟥, 𝗏𝖺𝗅𝗎𝖾𝟦],
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_rexw_and_4ₓi8(𝗏𝖺𝗅𝗎𝖾𝟣: i8, 𝗏𝖺𝗅𝗎𝖾𝟤: i8, 𝗏𝖺𝗅𝗎𝖾𝟥: i8, 𝗏𝖺𝗅𝗎𝖾𝟦: i8) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, 𝗏𝖺𝗅𝗎𝖾𝟤 as u8, 𝗏𝖺𝗅𝗎𝖾𝟥 as u8, 𝗏𝖺𝗅𝗎𝖾𝟦 as u8],
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_rexw_and_u32(𝗏𝖺𝗅𝗎𝖾𝟣: u32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8],
        emit_legacy_reg_address_ₓ86_64_ₓip_instruction_with_rexw_and_i32(𝗏𝖺𝗅𝗎𝖾𝟣: i32) =>
            [𝗏𝖺𝗅𝗎𝖾𝟣 as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 8) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 16) as u8, (𝗏𝖺𝗅𝗎𝖾𝟣 >> 24) as u8]
    }
}

impl<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮:
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 0> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 1> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 2> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 3> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 4> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 5> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 6> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 7> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 8> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 9> +
    𝒆𝒎𝒊𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 10> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 0> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 1> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 2> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 3> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 4> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 5> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 6> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 7> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 8> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 9> +
    𝒆𝒎𝒊𝒕_𝒔𝒆𝒈𝒎𝒆𝒏𝒕_𝒑𝒓𝒆𝒇𝒊𝒙𝒆𝒔_𝒂𝒏𝒅_𝒐𝒑𝒄𝒐𝒅𝒆<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼, 10>>
𝒆𝒎𝒊𝒕_𝒎𝒆𝒎𝒐𝒓𝒚_𝒊𝒏𝒔𝒕𝒓𝒖𝒄𝒕𝒊𝒐𝒏<𝓲𝓷𝓼𝓽𝓻𝓾𝓬𝓽𝓲𝓸𝓷_𝓹𝓻𝓮𝓯𝓲𝔁𝓮𝓼_𝓪𝓷𝓭_𝓸𝓹𝓬𝓸𝓭𝓮𝓼>
for 𝓮𝓶𝓲𝓽𝓽𝓮𝓻_𝓽𝔂𝓹𝓮 {}

use super::super::𝒆𝒎𝒊𝒕𝒕𝒆𝒓;
use super::super::𝒃𝒚𝒕𝒆_𝒆𝒎𝒊𝒕𝒕𝒆𝒓;

use super::𝗮𝗱𝗱𝗿𝗲𝘀𝘀::𝒂𝒅𝒅𝒓𝒆𝒔𝒔_ₓ86;
use super::𝗮𝗱𝗱𝗿𝗲𝘀𝘀::𝒂𝒅𝒅𝒓𝒆𝒔𝒔_8086;
use super::𝗮𝗱𝗱𝗿𝗲𝘀𝘀::𝐧𝐨_𝐢𝐧𝐝𝐞𝐱_𝐫𝐞𝐠𝐢𝐬𝐭𝐞𝐫;
